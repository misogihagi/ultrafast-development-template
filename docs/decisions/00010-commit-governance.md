## はじめに

- [決定](#決定)
- [ステータス](#ステータス)
- [背景](#背景)
- [想定される影響](#想定される影響)
- [検討した他の選択肢](#検討した他の選択肢)
- [参考文献](#参考文献)
- [結果](#結果)

## 決定

Git のコミットメッセージを統制する。

具体的には以下の手段を用いる。

1. Git のコミットメッセージは gitmoji に準拠する。
2. Git のコミットは commitlint を通す。
3. Git のコミットメッセージを扱いやすくするよう commitizen を導入する。

参照: [Git フックを利用する。具体的には lefthook を使う。](./00009-git-hook.md)

## ステータス

### <img src="https://raw.githubusercontent.com/FortAwesome/Font-Awesome/refs/heads/6.x/svgs/regular/circle-check.svg" width="10" alt="承認済み" /> 承認済み

## 背景

Git のコミットを統制する必要がある理由は、主に以下の点に集約されます。

### 1. 変更履歴の透明性と可読性の向上

- **変更内容の明確化:** 各コミットが「1 つの論理的な変更」を反映していることで、何が変更されたのかが一目で分かりやすくなります。例えば、「ボタンのデザインを変更する」というコミットと、「ボタンの挙動を変更する」というコミットを分けることで、それぞれの変更の意図が明確になります。
- **追跡とレビューの容易化:** 変更内容が明確であれば、コードレビューも効率的に行え、問題が発生した際にどのコミットで、なぜその変更が行われたのかを追跡しやすくなります。
- **プロジェクト全体の透明性向上:** きちんと統制されたコミット履歴は、プロジェクトの進化の過程を明確にし、新規メンバーがプロジェクトに参加した際にも、過去の変更を理解しやすくなります。

### 2. メンテナンス性の向上とバグの早期発見

- **バグの特定と修正:** バグが発生した場合、変更履歴をたどって問題を引き起こしたコミットを特定しやすくなります。粒度の細かいコミットであれば、そのコミットが導入した特定の変更だけに着目して修正できるため、デバッグの効率が上がります。
- **変更のロールバック（巻き戻し）:** 特定の変更が問題を引き起こした場合、その変更だけを簡単かつ安全に元に戻すことができます。複数の変更が混ざった大きなコミットでは、特定の変更だけを戻すのが困難になります。
- **影響範囲の評価:** 小さく意味のある単位でコミットされていると、変更がプロジェクト全体に与える影響を評価しやすくなります。

### 3. チーム開発の効率化と品質向上

- **コラボレーションの円滑化:** チームメンバー全員が共通のコミットルールに従うことで、お互いの変更を理解しやすくなり、マージ時のコンフリクトを減らすことにも繋がります。
- **コードレビューの負担軽減:** 適切に分割されたコミットは、コードレビューの負担を軽減し、レビューの質を向上させます。一度に大量の変更を含むコミットは、レビューアにとって負担が大きく、見落としが発生しやすくなります。
- **プロジェクト管理の簡素化:** 適切なコミット履歴は、プロジェクトの進捗状況を把握しやすくし、リリース管理やバージョン管理を効率的に行えます。

### 4. その他

- **コミットメッセージの重要性:** コミットメッセージも統制の重要な要素です。明確で分かりやすいコミットメッセージは、変更内容を言語化し、後から変更の意図を把握するために不可欠です。チーム内でコミットメッセージのルールを決めておくことで、より一貫性のある履歴が作成できます。

## 想定される影響

---

### 簡単になること

#### 1. 変更履歴の理解と追跡

- **変更内容の把握:** 各コミットが**単一の論理的な変更**を表すため、何がいつ、なぜ変更されたのかを素早く理解できます。
- **バグの原因特定:** 問題が発生した場合、どのコミットがバグを導入したのかを特定しやすくなります。`git bisect`のようなツールを効果的に活用でき、デバッグ時間を短縮できます。
- **コードレビューの効率化:** 変更が小さい単位で分けられているため、レビューアは個々の変更の意図と影響範囲を把握しやすく、レビューの質が向上します。

#### 2. プロジェクトのメンテナンスと安定性

- **安全なロールバック:** 特定の変更が意図しない問題を引き起こした場合、そのコミットだけを安全に元に戻す（`git revert`）ことが容易になります。
- **マージの簡素化:** 各コミットの粒度が細かいため、複数の開発者が同時に作業している場合でも、マージ時のコンフリクト発生を抑制し、解決を容易にします。
- **機能の分離:** 機能を小さな単位で開発し、それぞれのコミットで独立した変更として管理できるため、プロジェクトのモジュール性が向上し、将来的な拡張や改修がしやすくなります。

#### 3. チーム開発の効率とコミュニケーション

- **共通認識の形成:** コミットルールを共有することで、チームメンバー間の認識齟齬を減らし、共同作業がスムーズになります。
- **新規参入者のオンボーディング:** 整理されたコミット履歴は、新規メンバーがプロジェクトの歴史や設計思想を理解する上で非常に役立ちます。

---

### 難しくなること

#### 1. 開発プロセスの初期コストと学習曲線

- **コミットの習慣化:** 最初は、適切な粒度でコミットを分割する、明確なコミットメッセージを書くといった習慣を身につけるのに時間がかかります。特に経験の浅い開発者にとっては学習コストとなることがあります。
- **リベースの理解と実行:** 変更履歴を整理するために`git rebase -i`などのコマンドを多用する場合、その使い方やリスクを理解する必要があります。慣れないうちは間違った操作で履歴を破壊するリスクもあります。

#### 2. 厳密さによる手間の増加

- **頻繁なコミット:** 変更ごとにコミットを作成するため、開発中にコミットする回数が増えます。これにより、一時的に作業が中断される感覚を持つ開発者もいるかもしれません。
- **コミットの分割作業:** 意図せず複数の変更を含んでしまった場合、後からコミットを分割する作業（`git add -p`や`git reset --soft`など）が必要になり、手間がかかることがあります。

#### 3. 柔軟性の低下（初期段階）

- **初期の試行錯誤:** 開発の初期段階や、探索的なフェーズでは、頻繁な試行錯誤や変更が発生するため、その都度厳密なコミットルールを適用するのが煩わしく感じられることがあります。

---

## 検討した他の選択肢

### 1. 緩やかなコミット統制と「Squash & Merge」

**アプローチ:**
開発中は比較的自由にコミットし、多くの「作業途中のコミット（WIP: Work In Progress）」や「修正コミット」を許容します。ただし、プルリクエスト（PR）をマージする際には、これらのコミットを 1 つの意味のあるコミットにまとめる（squash）運用を採用します。

**メリット:**

- **開発の柔軟性:** 開発者は細かなコミットの粒度やメッセージに最初から気を遣う必要がなく、試行錯誤や WIP の状態を Git に気軽に記録できます。
- **履歴の整理:** 最終的にメインブランチに残るコミットは整理された状態になるため、最終的な履歴の可読性は維持されます。
- **デバッグのしやすさ（PR 内）:** プルリクエストのレビュー中は、詳細なコミット履歴が残っているため、変更の意図や過程を追跡しやすいという側面もあります。

**デメリット:**

- **PR 作成時の手間:** マージ前にコミットを squash する手間が発生します。特に大量のコミットがある場合、どのコミットをまとめるか、メッセージをどうするかを考える必要があります。
- **一時的な履歴の乱れ:** 開発中のブランチの履歴は乱雑になりがちで、他の開発者がそのブランチで作業する際には理解しにくい可能性があります。
- **問題の早期発見の遅れ:** 細かい粒度でのコミットがないため、どのコミットでバグが混入したかの特定が、PR のマージ後だと難しくなる可能性があります。

今回は「Squash & Merge」は使わないため却下。

## 参考文献

## 結果
